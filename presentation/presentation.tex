%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES
%----------------------------------------------------------------------------------------

\documentclass{beamer}


\mode<presentation> {

% The Beamer class comes with a number of default slide themes
% which change the colors and layouts of slides. Below this is a list
% of all the themes, uncomment each in turn to see what they look like.

%\usetheme{default}
%\usetheme{AnnArbor}
%\usetheme{Antibes}
%\usetheme{Bergen}
%\usetheme{Berkeley}
%\usetheme{Berlin}
%\usetheme{Boadilla}
\usetheme{CambridgeUS}
%\usetheme{Copenhagen}
%\usetheme{Darmstadt}
%\usetheme{Dresden}
%\usetheme{Frankfurt}
%\usetheme{Goettingen}
%\usetheme{Hannover}
%\usetheme{Ilmenau}
%\usetheme{JuanLesPins}
%\usetheme{Luebeck}
%\usetheme{Madrid}
%\usetheme{Malmoe}
%\usetheme{Marburg}
%\usetheme{Montpellier}
%\usetheme{PaloAlto}
%\usetheme{Pittsburgh}
%\usetheme{Rochester}
%\usetheme{Singapore}
%\usetheme{Szeged}
%\usetheme{Warsaw}

% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.

%\usecolortheme{albatross}
%\usecolortheme{beaver}
%\usecolortheme{beetle}
%\usecolortheme{crane}
%\usecolortheme{dolphin}
%\usecolortheme{dove}
%\usecolortheme{fly}
%\usecolortheme{lily}
%\usecolortheme{orchid}
%\usecolortheme{rose}
%\usecolortheme{seagull}
%\usecolortheme{seahorse}
%\usecolortheme{whale}
%\usecolortheme{wolverine}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

%\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}
\usepackage{standalone}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{tcolorbox}
\usepackage{media9}
\usepackage{float}
\usepackage{tkz-euclide}
\usepackage{amssymb,bm,amsmath}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\renewcommand{\vec}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\mat}[1]{\ensuremath{\boldsymbol{#1}}}
\usetikzlibrary{quotes,angles}
\newcommand{\inputTikZ}[2]{%
     \scalebox{#1}{\input{#2}}
}
\tcbuselibrary{raster}
\tcbuselibrary{fitting}
\definecolor{ku}{RGB}{144,26,30}
\definecolor{ku-yellow}{RGB}{255,249,25}
% Package for typesetting programs. Listings does not support fsharp, but a little modification goes a long way
\usepackage{listings}
\usepackage{color}
\usepackage{pdfpages}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{comment}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{turqusnumbers}{rgb}{0.17,0.57,0.69}
\definecolor{redstrings}{rgb}{0.5,0,0}
\lstdefinelanguage{FSharp}
{morekeywords={let, new, match, with, rec, open, module, namespace, type, of, member, and, for, in, do, begin, end, fun, function, try, mutable, if, then, else, return,
while},
keywordstyle=\color{magenta},
sensitive=false,
escapechar=\%,
morecomment=[l][\color{greencomments}]{///},
morecomment=[l][\color{green}]{//},
morecomment=[s][\color{greencomments}]{{(*}{*)}},
morestring=[b]",
stringstyle=\color{redstrings}
}
\lstdefinelanguage{CUDA}
{morekeywords={let, new, match, with, rec, open, module, namespace, type, of, member, and, for, in, do, begin, end, fun, function, try, mutable, if, then, else, return,
while},
keywordstyle=\color{magenta},
sensitive=false,
escapechar=\Â£,
morecomment=[l][\color{greencomments}]{///},
morecomment=[l][\color{green}]{//},
morecomment=[s][\color{greencomments}]{{(*}{*)}},
morestring=[b]",
stringstyle=\color{redstrings}
}
\lstdefinelanguage{Futhark}
{morekeywords={let, if, then, else, return, map, scatter, iota, replicate, reduce, scan, &&, ||, if, then, unsafe, loop, ->, <|, in, =>},
keywordstyle=\color{magenta},
sensitive=false,
escapechar=\%,
morecomment=[l][\color{greencomments}]{///},
morecomment=[l][\color{green}]{--},
morestring=[b]",
stringstyle=\color{redstrings}
}
\lstset{ %
basicstyle=\footnotesize\ttfamily,
commentstyle=\color{greencomments},    % comment style
keywordstyle=\color{magenta},       % keyword style
numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
numbers=left,
xleftmargin=2em,
tabsize=2,	                   % sets default tabsize to 2 spaces
rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
breaklines=true,                                        % sets automatic line breaking
stringstyle=\color{redstrings},     % string literal style
}
% \lstset{language=Futhark}          % Set your language (you can change the language for each code-block optionally)

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Pre-study]{Using Futhark for a fast, parallel implementation of forward and back projection in algebraic reconstruction methods - A pre-study} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{L\ae rke Pedersen and Mette Bjerg Lindh\o j} % Your name
\institute[DIKU] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
University of Copenhagen\\ % Your institution for the title page
}
\date{08/11/2018} % Date, can be changed to a custom date

\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

\begin{frame}
\frametitle{SIRT}
Solve the problem:
\begin{align}
\vec{f}^{\ast}=argmin_{\vec{f}}\norm{\vec{p}-\mat{A}\vec{f}}
\end{align}
iteratively using this update step:
\begin{align}
\vec{f}^{n} = \vec{f}^{(n-1)}+\mat{C}\mat{A}^{T}\mat{R}(\vec{p}-\mat{A}\vec{f}^{(n-1)}),
\end{align}

where $\mat{C}$ and $\mat{R}$ are the diagonal matrices containing the inverse column and row sums of the system matrix respectively.
\end{frame}

\begin{frame}
\frametitle{The system matrix}
\inputTikZ{0.6}{figures/weightings.tex}
\end{frame}

\begin{frame}
\frametitle{The problem is in the size}
\begin{itemize}
\item{Consider reconstructing a single slize of a volume from a detector of size $n\times n$}
\item{The number of rays is $n$}
\item{The number of angles is $\frac{n\cdot\pi}{2}$}
\item{A typical value for $n$ is 2048 }
\item{In semi sparse format the matrix will take up $2\cdot4\cdot2048\cdot\lceil\frac{2048\cdot\pi}{2}\rceil\cdot (2\cdot2048-1)\approx 216GB$}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{System matrix computation}
\begin{figure}[!h]
\begin{lstlisting}[frame=single]
for ray = 0; ray < numberofrays; ray++ //parallel
	for pixel = 0; pixel < pixels; pixel++ //parallel
		if ray intersects pixel:
        (p1,p2) = intersectionpoints pixel ray
        A[ray][pixel] = distance p1 p2
\end{lstlisting}
  \caption{$W(r,n)=O(r\cdot n^2)$, $D(r,n)=O(1)$}
\end{figure}
\begin{figure}[!h]
\begin{lstlisting}[frame=single]
for ray in rays //parallel
	while (isingrid focuspoint) //seq
        pixel = calculatepixel focuspoint ray
        nextpoint = findnextpoint focuspoint ray
        A[ray][pixel] = distance nextpoint focuspoint
        focuspoint = nextpoint
\end{lstlisting}
  \caption{$W(r,n)=O(r\cdot n)$, $D(r,n)=O(n)$}
\end{figure}
\end{frame}

\begin{frame}
  \frametitle{Flattening}
  Utilizing nested parallelism is notoriously difficult, flattening the code can give marked improvements. However, flattening is also a way to systematically reason about nested code, as well as transforming it. Our project is currently a mix of flattened and nested code.\newline
  \newline
  I will look into flattening our code in an example of one of our primary work areas, forward projection
\end{frame}

\begin{frame}[fragile]
\frametitle{The format of the matrix}
\begin{figure}[!h]
\begin{lstlisting}[frame=single]
[[(0.01,0),(0.04,3),(0.01,2),(-1.0,-1)],
[ (0.10,0),(0.40,3),(0.05,2),( 1.0,-1)],
[ (0.01,1),(0.04,5),(-1.,-1),(-1.0,-1)],
[...                                  ],
[...                                  ],
[...                                  ]]
\end{lstlisting}
  \caption{An example of the matrix output format.}
\end{figure}
\end{frame}

%
% \begin{frame}[fragile]
%   \frametitle{Flattening}
%   Forward projection is handled as a matrix vector multiplication. We utilize both a nested version and a flattened version. %TODO check code after compile, is it flat
%   The nested version will, for each row, multiply the row and vector and get the sum.
%   \begin{lstlisting}[frame=single, language=Futhark]
%     map (\row ->
%       reduce (+) 0 <| map (\(v, ind) ->
%         unsafe (if ind == -1 then 0.0 else v*vect[ind])
%       ) row
%     ) mat_vals
%   \end{lstlisting}
%   Flattening this will require a flattened matrix, (calculating) a flag array,
% \end{frame}

\begin{frame}[fragile]
  \frametitle{Flattening}
  Forward projection is handled as a matrix vector multiplication. We utilize both a nested version and a flattened version. %TODO check code after compile, is it flat
  \begin{lstlisting}[frame=single, language=Futhark]
    map (\row -> reduce (+) 0 <| map (\(v, ind) -> unsafe (if ind == -1 then 0.0 else v*vect[ind])) row ) mat_vals
  \end{lstlisting}
  This translates to, still nested;
  \begin{lstlisting}[frame=single, language=Futhark]
    map(\row ->
      let (ts, fs) = partition2 (\(_, ind) -> != -1) row Work(n), depth(log(n)) --if-then-else
      let multiplied = map (\(v, ind) -> v*vect[ind]) ts work(n)
      in reduce (+) 0 multiplied Work(n), depth(log(n))
    ) mat_vals
  \end{lstlisting}
\end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Flattening}
%   \begin{lstlisting}[frame=single, language=Futhark]
%     map (\row -> reduce (+) 0 <| map (\(v, ind) -> unsafe (if ind == -1 then 0.0 else v*vect[ind])) row ) mat_vals
%   \end{lstlisting}
%   This translates to, still nested;
%   \begin{lstlisting}[frame=single, language=Futhark]
%     make flag array
%
%   \end{lstlisting}
% \end{frame}

\begin{frame}[fragile]
  \frametitle{Flattening}

  \begin{lstlisting}[frame=single, language=Futhark]
    map (\row -> reduce (+) 0 <| map (\(v, ind) -> unsafe (if ind == -1 then 0.0 else v*vect[ind])) row ) mat_vals
  \end{lstlisting}
  \begin{itemize}
    \item A flattened matrix enforces coalesed reads from memory
    \item In SIMD a if-then-else is executed by evaluating the if, executing the then brach while the rest of the cores wait, then the same for the else branch. Partition means coalesed reads going forward
    \item The cons of flattening are that it may require impractically high memory-usage which is already an issue in our problem, and does not account for locality of reference.
  \end{itemize}
\end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Flattening}
%   \begin{lstlisting}[frame=single, language=Futhark]
%     map (\row -> reduce (+) 0 <| map (\(v, ind) -> unsafe (if ind == -1 then 0.0 else v*vect[ind])) row ) mat_vals
%   \end{lstlisting}
%   \begin{itemize}
%     \item First step is to make a flag array, based on the matrix shape, and flatten the matrix
%     \item Then
%   \end{itemize}
%   \end{frame}

\begin{frame}
\frametitle{Code transformations}
\begin{itemize}
\item{By dumping the compiled code with the --dump command and getting the time spend in different kernels with the -D option we found that most of the time was spend on calculating the system matrix}
\item{Futhark can not merge a map with a loop}
\item{The code had a lot of branching}
\item{We tried to mitigate this by removing as much from the loop as possible, and reorganising branches.}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Changing the algorithm}
\begin{figure}[!h]
\begin{lstlisting}[frame=single]
for ray in rays //parallel
  for i=-halfsize; i < halfsize; i++ //parallel
        (l1,pixel1) = intersection1 ray i
        (l2,pixel2) = intersection2 ray i
        A[ray][pixel1] = l1
        A[ray][pixel2] = l2
\end{lstlisting}
  \caption{$W(r,n)=O(r\cdot n)$, $D(r,n)=O(1)$}
\end{figure}
\end{frame}

\begin{frame}[fragile]
\frametitle{Flattening the new algorithm}
\begin{figure}[!h]
\begin{lstlisting}[frame=single, language=Futhark,basicstyle=\tiny]
let weights_doublepar(angles: []f32) (rays: []f32) (gridsize: i32): [][](f32,i32) =
     let halfgridsize = gridsize/2
     let entryexitpoints =  convert2entryexit angles rays (r32(halfgridsize))
     in map(\(ent,ext) -> (flatten(map (\i ->
               calculate_weight ent ext i gridsize
          )((-halfgridsize)...(halfgridsize-1))))) entryexitpoints
\end{lstlisting}
\begin{lstlisting}[frame=single, language=Futhark,basicstyle=\tiny]
let weights_doublepar_flat [n] [m](angles: [n]f32) (rays: [m]f32) (gridsize: i32): [](f32,i32) =
     let halfgridsize = gridsize/2
     let entryexitpoints =  convert2entryexit angles rays (r32(halfgridsize))
     let replicatedentries = mapreplicate gridsize entryexitpoints
     let replicatedcolumns = flatten(replicate (n*m) ((-halfgridsize)...(halfgridsize-1)))
     let flatgridEntryexit = zip replicatedentries replicatedcolumns
     in flatten(map(\((p1,p2),i) ->
               calculate_weight p1 p2 i gridsize
          ) flatgridEntryexit)
\end{lstlisting}
  \caption{Flattening the new algorithm.}
\end{figure}
\end{frame}

 \begin{frame}
 \nocite{*}
 \bibliographystyle{plain}
 \bibliography{gpu}
 \end{frame}

\end{document}
