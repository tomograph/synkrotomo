\section{Introduction}
Computed tomography is the inverse problem of reconstructing an image or volume from its x-ray projections. The x-ray source spins around the object to be analyzed and sends x-rays that hit a detector on the oposite side. The detector shows how much of each x-ray was attenuated when passing through the volume. In this report we will focus on the bottlenecks of an algebraic reconstruction algorithm called the Simulataneous Iterative Reconstruction Algorithm (SIRT) and investigate how we may use the high level data-parallel language Futhark for implememting a fast version of this algorithm. The reason for chosing this algorithm is that it provides good reconstruction quality under non-optimal circumstances, but unfortunately has very poor performance compared to techniques such as filtered backprojection.\\
In algebraic reconstruction we solve the problem as a linear system of equations. The main idea is that the process can be modelled as a linear transformation by discretizng the object to be reconstructed into $N$ pixels. First we place a coordinate system with origo at the center of the object to be reconstructed and denote by $\vec{\theta}$ the vector of angles between the positions of the source and origo. For each angle several x-rays are cast from the source. We denote by the vector $\vec{\rho}$ the signed distances from each line to origo. The data produced by the process is called the sinogram. Then the sinogram values $p_i$ for each $(\theta_k,\rho_l)$  are a weighted sum of the attenuations at each pixel $f_j$ that the $(\theta_k,\rho_l)$ ray passes through:

\begin{align}
\sum_{j=1}^N a_{ij}f_j=p_i
\end{align}

Where $a_{ij}$ are the weights, corresponding to the fraction of the pixel $j$ that the ray $i$ covers.

\begin{figure}
\centering
\inputTikZ{1}{figures/weightings.tex}
\caption{Example of a weighting $a_{ij}$.}
\label{fig:weightings}
\end{figure}
Writing all the projections as a column vector $\vec{p}$ and the attenuation values to be reconstructed as a column vector $\vec{f}$ the weightings are represented as an $M\times N$ matrix $\mat{A}$, we obtain a linear system of the form:

\begin{align}
\vec{p} = \mat{A}\vec{f}
\end{align}

These systems of equations may easily be solved under the right circumstances, where $M = N$. However this is rarely the case. In most real cases $M > N$, i.e. the number of projections is larger than the number of pixels to be reconstructed and the size of the matrix is very large - more about this in the next section.\\
However, the algebraic reconstruction methods also have some advantages. Since the model closely relates to the real world scenario the weightings can be refactored to take irregularities in the setup, such as differences in beam energies or irregular geometries and missing data into account. Furthermore these methods generally give better image quality than analytic methods when the data is sparse.\\

A linear system like this is typically solved by minimizing some norm:

\begin{align}
\norm{\mat{A}\vec{f}-\vec{p}}
\end{align}

An example is the SIRT algorithm. The action of the matrix $\mat{A}$ is called the \emph{forward projection}, and the matrix itself is called the \emph{system matrix},\emph{projection matrix} or \emph{radon matrix}. Each row of $\mat{A}$ represents the coefficients of the equation for one ray. The action of the transposed projection matrix $\mat{A}^{T}$ on the sinogram vector is called the \emph{backprojection}, and can be vizualized as smearing the projection values across the reconstruction in the direction of the ray, or equivalently summing up the contrubitions of each ray for a given pixel. The idea behind the SIRT algorithm is to forward project the current reconstruction, then subtract this from the original projection data and do a weighted backprojection resulting in a correction factor which can be added to the current reconstruction. The update equeation is:

\begin{align}
\vec{f}^{n} = \vec{f}^{(n-1)}+\mat{C}\mat{A}^{T}\mat{R}(\vec{p}-\mat{A}\vec{f}^{(n-1)}),
\end{align}

where $\mat{C}$ and $\mat{R}$ are the diagonal matrices containing the inverse column and row sums of the system matrix respectively.\\

It can be shown that this iterative scheme solves the problem:

\begin{align}
 \vec{f}^{\ast}=argmin_{\vec{f}}\norm{\vec{p}-\mat{A}\vec{f}}_{\mat{R}},
\end{align}

where $\norm{\vec{x}}_{\mat{R}} = \vec{x}^T\mat{R}\vec{x}$.

\begin{figure}
\includegraphics[width=\linewidth]{images/sirt.png}
\caption{An illustration of the SIRT algorithm.}
\label{fig:sirt}
\end{figure}

The backprojection and foward projection operations are standard operations in many iterative algebraic reconstruction methods and are the bottle necks of the algorithms~\cite{footprints2010}. Therefore, our main focus has been on optimizing these operations.\\
Different beam geometries exist, such as parallel beams, fan beams and cone beams. The geometry must be considered when constructing the system matrix. However as this study is intended for applications with synchrotron data only parallel beam geometries will be considered. Furthermore, we will only consider reconstructions of 2D images, since this is simply a pre-study and it makes the problem conceptually easier to follow.\\
