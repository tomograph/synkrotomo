\section{Nested parallel forward and back projctions}
A first approach at forward and backprojection was to do a nested parallel version and using computed chunks of the system matrix.\\
A looped version of the forward projection with the system matrix cut in $steps$ chunks looks like this:

\begin{figure}[h]
\begin{lstlisting}[frame=single]
for step = 0; step < steps; step++
	A = getRays(raysperstep)
	for ray = 0; ray < raysperstep; row++
		acc = 0.0
		for p = 0; p<numpixels; p++
			acc+= A[ray][p]*image[p]
		FP[step*raysperstep+ray] = acc

this can be written in futhark like pseudo code as:

loop (output, step, raysperstep)
	let A = getRays raysperstep step
	let partresult = map (\row -> reduce (+) 0 <| map ( \i -> row[i]*vector[i] ) (iota (length row)) ) A
	in (output++partresult, step, raysperstep)
\end{lstlisting}
\caption{A looped version of the forward projection, where the raysperstep should be chosen such that the computations fit in the memory. $step*raysperstep$ should equal the total number of rows.}
\end{figure}
\begin{figure}[h]
\begin{lstlisting}[frame=single]
for step = 0; step < steps; step++
	A = getRays(raysperstep)
	AT = A.transpose()
	for p = 0; p<numpixels; p++
		acc = 0.0
		for ray = 0; ray<raysperstep; ray++
			acc+= AT[p][ray]*sinogram[ray]
		BP[p] += acc

this can be written in futhark like pseudo code as:

loop (output, step, raysperstep)
	let A = getRays raysperstep step
	let AT = transpose A
	let partresult = map (\row -> reduce (+) 0 <| map2 (*) row vect ) AT
	map2 (+) partresult output
	in (output, step, raysperstep)
\end{lstlisting}
  \caption{A looped version of the back projection, where the raysperstep should be the largest number possible such that the computations fit in the memory. $step*raysperstep$ should equal the total number of rows.}
\end{figure}
\todo{L\ae rke says there are errors in futhark bp code. We should fix it}

\todo{Insert futhark implementations of nested version of FP and BP and the time it takes to run. Note which loops are parallel and why. Do work depth analysis of these algorithms. Make graphs displaying memory usage. Write something about why BP is slower than FP, what can we do about it?}
